// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package gtfsdb

import (
	"context"
	"database/sql"
	"strings"
)

const clearAgencies = `-- name: ClearAgencies :exec
DELETE FROM agencies
`

func (q *Queries) ClearAgencies(ctx context.Context) error {
	_, err := q.exec(ctx, q.clearAgenciesStmt, clearAgencies)
	return err
}

const clearBlockTripEntries = `-- name: ClearBlockTripEntries :exec
DELETE FROM block_trip_entry
`

func (q *Queries) ClearBlockTripEntries(ctx context.Context) error {
	_, err := q.exec(ctx, q.clearBlockTripEntriesStmt, clearBlockTripEntries)
	return err
}

const clearBlockTripIndices = `-- name: ClearBlockTripIndices :exec
DELETE FROM block_trip_index
`

func (q *Queries) ClearBlockTripIndices(ctx context.Context) error {
	_, err := q.exec(ctx, q.clearBlockTripIndicesStmt, clearBlockTripIndices)
	return err
}

const clearCalendar = `-- name: ClearCalendar :exec
DELETE FROM calendar
`

func (q *Queries) ClearCalendar(ctx context.Context) error {
	_, err := q.exec(ctx, q.clearCalendarStmt, clearCalendar)
	return err
}

const clearRoutes = `-- name: ClearRoutes :exec
DELETE FROM routes
`

func (q *Queries) ClearRoutes(ctx context.Context) error {
	_, err := q.exec(ctx, q.clearRoutesStmt, clearRoutes)
	return err
}

const clearShapes = `-- name: ClearShapes :exec
DELETE FROM shapes
`

func (q *Queries) ClearShapes(ctx context.Context) error {
	_, err := q.exec(ctx, q.clearShapesStmt, clearShapes)
	return err
}

const clearStopTimes = `-- name: ClearStopTimes :exec
DELETE FROM stop_times
`

func (q *Queries) ClearStopTimes(ctx context.Context) error {
	_, err := q.exec(ctx, q.clearStopTimesStmt, clearStopTimes)
	return err
}

const clearStops = `-- name: ClearStops :exec
DELETE FROM stops
`

func (q *Queries) ClearStops(ctx context.Context) error {
	_, err := q.exec(ctx, q.clearStopsStmt, clearStops)
	return err
}

const clearTrips = `-- name: ClearTrips :exec
DELETE FROM trips
`

func (q *Queries) ClearTrips(ctx context.Context) error {
	_, err := q.exec(ctx, q.clearTripsStmt, clearTrips)
	return err
}

const createAgency = `-- name: CreateAgency :one
INSERT
OR REPLACE INTO agencies (
    id,
    name,
    url,
    timezone,
    lang,
    phone,
    fare_url,
    email
)
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?) RETURNING id, name, url, timezone, lang, phone, fare_url, email
`

type CreateAgencyParams struct {
	ID       string
	Name     string
	Url      string
	Timezone string
	Lang     sql.NullString
	Phone    sql.NullString
	FareUrl  sql.NullString
	Email    sql.NullString
}

func (q *Queries) CreateAgency(ctx context.Context, arg CreateAgencyParams) (Agency, error) {
	row := q.queryRow(ctx, q.createAgencyStmt, createAgency,
		arg.ID,
		arg.Name,
		arg.Url,
		arg.Timezone,
		arg.Lang,
		arg.Phone,
		arg.FareUrl,
		arg.Email,
	)
	var i Agency
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Timezone,
		&i.Lang,
		&i.Phone,
		&i.FareUrl,
		&i.Email,
	)
	return i, err
}

const createBlockTripEntry = `-- name: CreateBlockTripEntry :exec
INSERT INTO block_trip_entry (
    block_trip_index_id,
    trip_id,
    block_id,
    service_id,
    block_trip_sequence
)
VALUES
    (?, ?, ?, ?, ?)
`

type CreateBlockTripEntryParams struct {
	BlockTripIndexID  int64
	TripID            string
	BlockID           sql.NullString
	ServiceID         string
	BlockTripSequence int64
}

func (q *Queries) CreateBlockTripEntry(ctx context.Context, arg CreateBlockTripEntryParams) error {
	_, err := q.exec(ctx, q.createBlockTripEntryStmt, createBlockTripEntry,
		arg.BlockTripIndexID,
		arg.TripID,
		arg.BlockID,
		arg.ServiceID,
		arg.BlockTripSequence,
	)
	return err
}

const createBlockTripIndex = `-- name: CreateBlockTripIndex :one

INSERT INTO block_trip_index (
    index_key,
    service_ids,
    stop_sequence_key,
    created_at
)
VALUES
    (?, ?, ?, ?)
RETURNING id
`

type CreateBlockTripIndexParams struct {
	IndexKey        string
	ServiceIds      string
	StopSequenceKey string
	CreatedAt       int64
}

// BlockTripIndex queries
func (q *Queries) CreateBlockTripIndex(ctx context.Context, arg CreateBlockTripIndexParams) (int64, error) {
	row := q.queryRow(ctx, q.createBlockTripIndexStmt, createBlockTripIndex,
		arg.IndexKey,
		arg.ServiceIds,
		arg.StopSequenceKey,
		arg.CreatedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createCalendar = `-- name: CreateCalendar :one
INSERT
OR REPLACE INTO calendar (
    id,
    monday,
    tuesday,
    wednesday,
    thursday,
    friday,
    saturday,
    sunday,
    start_date,
    end_date
)
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id, monday, tuesday, wednesday, thursday, friday, saturday, sunday, start_date, end_date
`

type CreateCalendarParams struct {
	ID        string
	Monday    int64
	Tuesday   int64
	Wednesday int64
	Thursday  int64
	Friday    int64
	Saturday  int64
	Sunday    int64
	StartDate string
	EndDate   string
}

func (q *Queries) CreateCalendar(ctx context.Context, arg CreateCalendarParams) (Calendar, error) {
	row := q.queryRow(ctx, q.createCalendarStmt, createCalendar,
		arg.ID,
		arg.Monday,
		arg.Tuesday,
		arg.Wednesday,
		arg.Thursday,
		arg.Friday,
		arg.Saturday,
		arg.Sunday,
		arg.StartDate,
		arg.EndDate,
	)
	var i Calendar
	err := row.Scan(
		&i.ID,
		&i.Monday,
		&i.Tuesday,
		&i.Wednesday,
		&i.Thursday,
		&i.Friday,
		&i.Saturday,
		&i.Sunday,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const createCalendarDate = `-- name: CreateCalendarDate :one
INSERT
OR REPLACE INTO calendar_dates (service_id, date, exception_type)
VALUES
    (?, ?, ?) RETURNING service_id, date, exception_type
`

type CreateCalendarDateParams struct {
	ServiceID     string
	Date          string
	ExceptionType int64
}

func (q *Queries) CreateCalendarDate(ctx context.Context, arg CreateCalendarDateParams) (CalendarDate, error) {
	row := q.queryRow(ctx, q.createCalendarDateStmt, createCalendarDate, arg.ServiceID, arg.Date, arg.ExceptionType)
	var i CalendarDate
	err := row.Scan(&i.ServiceID, &i.Date, &i.ExceptionType)
	return i, err
}

const createRoute = `-- name: CreateRoute :one
INSERT
OR REPLACE INTO routes (
    id,
    agency_id,
    short_name,
    long_name,
    desc,
    type,
    url,
    color,
    text_color,
    continuous_pickup,
    continuous_drop_off
)
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id, agency_id, short_name, long_name, "desc", type, url, color, text_color, continuous_pickup, continuous_drop_off
`

type CreateRouteParams struct {
	ID                string
	AgencyID          string
	ShortName         sql.NullString
	LongName          sql.NullString
	Desc              sql.NullString
	Type              int64
	Url               sql.NullString
	Color             sql.NullString
	TextColor         sql.NullString
	ContinuousPickup  sql.NullInt64
	ContinuousDropOff sql.NullInt64
}

func (q *Queries) CreateRoute(ctx context.Context, arg CreateRouteParams) (Route, error) {
	row := q.queryRow(ctx, q.createRouteStmt, createRoute,
		arg.ID,
		arg.AgencyID,
		arg.ShortName,
		arg.LongName,
		arg.Desc,
		arg.Type,
		arg.Url,
		arg.Color,
		arg.TextColor,
		arg.ContinuousPickup,
		arg.ContinuousDropOff,
	)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.AgencyID,
		&i.ShortName,
		&i.LongName,
		&i.Desc,
		&i.Type,
		&i.Url,
		&i.Color,
		&i.TextColor,
		&i.ContinuousPickup,
		&i.ContinuousDropOff,
	)
	return i, err
}

const createShape = `-- name: CreateShape :one
INSERT
OR REPLACE INTO shapes (shape_id, lat, lon, shape_pt_sequence, shape_dist_traveled)
VALUES
    (?, ?, ?, ?, ?) RETURNING id, shape_id, lat, lon, shape_pt_sequence, shape_dist_traveled
`

type CreateShapeParams struct {
	ShapeID           string
	Lat               float64
	Lon               float64
	ShapePtSequence   int64
	ShapeDistTraveled sql.NullFloat64
}

func (q *Queries) CreateShape(ctx context.Context, arg CreateShapeParams) (Shape, error) {
	row := q.queryRow(ctx, q.createShapeStmt, createShape,
		arg.ShapeID,
		arg.Lat,
		arg.Lon,
		arg.ShapePtSequence,
		arg.ShapeDistTraveled,
	)
	var i Shape
	err := row.Scan(
		&i.ID,
		&i.ShapeID,
		&i.Lat,
		&i.Lon,
		&i.ShapePtSequence,
		&i.ShapeDistTraveled,
	)
	return i, err
}

const createStop = `-- name: CreateStop :one
INSERT
OR REPLACE INTO stops (
    id,
    code,
    name,
    desc,
    lat,
    lon,
    zone_id,
    url,
    location_type,
    timezone,
    wheelchair_boarding,
    platform_code,
    direction
)
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id, code, name, "desc", lat, lon, zone_id, url, location_type, timezone, wheelchair_boarding, platform_code, direction, parent_station
`

type CreateStopParams struct {
	ID                 string
	Code               sql.NullString
	Name               sql.NullString
	Desc               sql.NullString
	Lat                float64
	Lon                float64
	ZoneID             sql.NullString
	Url                sql.NullString
	LocationType       sql.NullInt64
	Timezone           sql.NullString
	WheelchairBoarding sql.NullInt64
	PlatformCode       sql.NullString
	Direction          sql.NullString
}

func (q *Queries) CreateStop(ctx context.Context, arg CreateStopParams) (Stop, error) {
	row := q.queryRow(ctx, q.createStopStmt, createStop,
		arg.ID,
		arg.Code,
		arg.Name,
		arg.Desc,
		arg.Lat,
		arg.Lon,
		arg.ZoneID,
		arg.Url,
		arg.LocationType,
		arg.Timezone,
		arg.WheelchairBoarding,
		arg.PlatformCode,
		arg.Direction,
	)
	var i Stop
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Desc,
		&i.Lat,
		&i.Lon,
		&i.ZoneID,
		&i.Url,
		&i.LocationType,
		&i.Timezone,
		&i.WheelchairBoarding,
		&i.PlatformCode,
		&i.Direction,
		&i.ParentStation,
	)
	return i, err
}

const createStopTime = `-- name: CreateStopTime :one
INSERT
OR REPLACE INTO stop_times (
    trip_id,
    arrival_time,
    departure_time,
    stop_id,
    stop_sequence,
    stop_headsign,
    pickup_type,
    drop_off_type,
    shape_dist_traveled,
    timepoint
)
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING trip_id, arrival_time, departure_time, stop_id, stop_sequence, stop_headsign, pickup_type, drop_off_type, shape_dist_traveled, timepoint
`

type CreateStopTimeParams struct {
	TripID            string
	ArrivalTime       int64
	DepartureTime     int64
	StopID            string
	StopSequence      int64
	StopHeadsign      sql.NullString
	PickupType        sql.NullInt64
	DropOffType       sql.NullInt64
	ShapeDistTraveled sql.NullFloat64
	Timepoint         sql.NullInt64
}

func (q *Queries) CreateStopTime(ctx context.Context, arg CreateStopTimeParams) (StopTime, error) {
	row := q.queryRow(ctx, q.createStopTimeStmt, createStopTime,
		arg.TripID,
		arg.ArrivalTime,
		arg.DepartureTime,
		arg.StopID,
		arg.StopSequence,
		arg.StopHeadsign,
		arg.PickupType,
		arg.DropOffType,
		arg.ShapeDistTraveled,
		arg.Timepoint,
	)
	var i StopTime
	err := row.Scan(
		&i.TripID,
		&i.ArrivalTime,
		&i.DepartureTime,
		&i.StopID,
		&i.StopSequence,
		&i.StopHeadsign,
		&i.PickupType,
		&i.DropOffType,
		&i.ShapeDistTraveled,
		&i.Timepoint,
	)
	return i, err
}

const createTrip = `-- name: CreateTrip :one
INSERT
OR REPLACE INTO trips (
    id,
    route_id,
    service_id,
    trip_headsign,
    trip_short_name,
    direction_id,
    block_id,
    shape_id,
    wheelchair_accessible,
    bikes_allowed
)
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id, route_id, service_id, trip_headsign, trip_short_name, direction_id, block_id, shape_id, wheelchair_accessible, bikes_allowed
`

type CreateTripParams struct {
	ID                   string
	RouteID              string
	ServiceID            string
	TripHeadsign         sql.NullString
	TripShortName        sql.NullString
	DirectionID          sql.NullInt64
	BlockID              sql.NullString
	ShapeID              sql.NullString
	WheelchairAccessible sql.NullInt64
	BikesAllowed         sql.NullInt64
}

func (q *Queries) CreateTrip(ctx context.Context, arg CreateTripParams) (Trip, error) {
	row := q.queryRow(ctx, q.createTripStmt, createTrip,
		arg.ID,
		arg.RouteID,
		arg.ServiceID,
		arg.TripHeadsign,
		arg.TripShortName,
		arg.DirectionID,
		arg.BlockID,
		arg.ShapeID,
		arg.WheelchairAccessible,
		arg.BikesAllowed,
	)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.RouteID,
		&i.ServiceID,
		&i.TripHeadsign,
		&i.TripShortName,
		&i.DirectionID,
		&i.BlockID,
		&i.ShapeID,
		&i.WheelchairAccessible,
		&i.BikesAllowed,
	)
	return i, err
}

const getActiveServiceIDsForDate = `-- name: GetActiveServiceIDsForDate :many
WITH formatted_date AS (
    SELECT STRFTIME('%w', SUBSTR(?1, 1, 4) || '-' || SUBSTR(?1, 5, 2) || '-' || SUBSTR(?1, 7, 2)) AS weekday
),
base_services AS (
    SELECT c.id AS service_id
    FROM calendar c, formatted_date fd
    WHERE c.start_date <= ?1
      AND c.end_date >= ?1
      AND (
        (fd.weekday = '0' AND c.sunday = 1) OR
        (fd.weekday = '1' AND c.monday = 1) OR
        (fd.weekday = '2' AND c.tuesday = 1) OR
        (fd.weekday = '3' AND c.wednesday = 1) OR
        (fd.weekday = '4' AND c.thursday = 1) OR
        (fd.weekday = '5' AND c.friday = 1) OR
        (fd.weekday = '6' AND c.saturday = 1)
      )
),
removed_services AS (
    SELECT service_id
    FROM calendar_dates
    WHERE date = ?1
      AND exception_type = 2
),
added_services AS (
    SELECT service_id
    FROM calendar_dates
    WHERE date = ?1
      AND exception_type = 1
)
SELECT DISTINCT service_id
FROM base_services
WHERE service_id NOT IN (SELECT service_id FROM removed_services)
UNION
SELECT DISTINCT service_id FROM added_services
`

func (q *Queries) GetActiveServiceIDsForDate(ctx context.Context, substr interface{}) ([]string, error) {
	rows, err := q.query(ctx, q.getActiveServiceIDsForDateStmt, getActiveServiceIDsForDate, substr)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var service_id string
		if err := rows.Scan(&service_id); err != nil {
			return nil, err
		}
		items = append(items, service_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveStops = `-- name: GetActiveStops :many
SELECT DISTINCT s.id, s.code, s.name, s."desc", s.lat, s.lon, s.zone_id, s.url, s.location_type, s.timezone, s.wheelchair_boarding, s.platform_code, s.direction, s.parent_station
FROM stops s
INNER JOIN stop_times st ON s.id = st.stop_id
`

func (q *Queries) GetActiveStops(ctx context.Context) ([]Stop, error) {
	rows, err := q.query(ctx, q.getActiveStopsStmt, getActiveStops)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stop
	for rows.Next() {
		var i Stop
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Desc,
			&i.Lat,
			&i.Lon,
			&i.ZoneID,
			&i.Url,
			&i.LocationType,
			&i.Timezone,
			&i.WheelchairBoarding,
			&i.PlatformCode,
			&i.Direction,
			&i.ParentStation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveTripForRouteAtTime = `-- name: GetActiveTripForRouteAtTime :one
SELECT
    t.id, t.route_id, t.service_id, t.trip_headsign, t.trip_short_name,
    t.direction_id, t.block_id, t.shape_id, t.wheelchair_accessible, t.bikes_allowed
FROM trips t
JOIN block_trip_entry bte ON t.id = bte.trip_id
JOIN stop_times st_first ON t.id = st_first.trip_id AND st_first.stop_sequence = (
    SELECT MIN(stop_sequence) FROM stop_times WHERE trip_id = t.id
)
JOIN stop_times st_last ON t.id = st_last.trip_id AND st_last.stop_sequence = (
    SELECT MAX(stop_sequence) FROM stop_times WHERE trip_id = t.id
)
WHERE bte.block_trip_index_id IN (/*SLICE:index_ids*/?)
  AND t.route_id = ?2
  AND bte.service_id IN (/*SLICE:service_ids*/?)
  AND st_first.departure_time <= ?4
  AND st_last.arrival_time >= ?5
ORDER BY st_first.departure_time DESC
LIMIT 1
`

type GetActiveTripForRouteAtTimeParams struct {
	IndexIds    []int64
	RouteID     string
	ServiceIds  []string
	CurrentTime int64
	FromTime    int64
}

// Find the ONE trip from a specific route that is active at the given time
// A trip is active if current_time falls within its stop times
func (q *Queries) GetActiveTripForRouteAtTime(ctx context.Context, arg GetActiveTripForRouteAtTimeParams) (Trip, error) {
	query := getActiveTripForRouteAtTime
	var queryParams []interface{}
	if len(arg.IndexIds) > 0 {
		for _, v := range arg.IndexIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:index_ids*/?", strings.Repeat(",?", len(arg.IndexIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:index_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.RouteID)
	if len(arg.ServiceIds) > 0 {
		for _, v := range arg.ServiceIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:service_ids*/?", strings.Repeat(",?", len(arg.ServiceIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:service_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.CurrentTime)
	queryParams = append(queryParams, arg.FromTime)
	row := q.queryRow(ctx, nil, query, queryParams...)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.RouteID,
		&i.ServiceID,
		&i.TripHeadsign,
		&i.TripShortName,
		&i.DirectionID,
		&i.BlockID,
		&i.ShapeID,
		&i.WheelchairAccessible,
		&i.BikesAllowed,
	)
	return i, err
}

const getActiveTripInBlockAtTime = `-- name: GetActiveTripInBlockAtTime :one
SELECT t.id
FROM trips t
JOIN stop_times st_first ON t.id = st_first.trip_id AND st_first.stop_sequence = (
        SELECT MIN(stop_sequence) FROM stop_times WHERE trip_id = t.id
)
JOIN stop_times st_last ON t.id = st_last.trip_id AND st_last.stop_sequence = (
        SELECT MAX(stop_sequence) FROM stop_times WHERE trip_id = t.id
)
WHERE t.block_id = ?1
    AND t.service_id IN (/*SLICE:service_ids*/?)
    AND st_first.departure_time <= ?3
    AND st_last.arrival_time >= ?3
ORDER BY st_first.departure_time ASC
LIMIT 1
`

type GetActiveTripInBlockAtTimeParams struct {
	BlockID     sql.NullString
	ServiceIds  []string
	CurrentTime int64
}

// Find the currently active trip in a specific block at the given time
// Returns the trip whose stop times contain the current time (with late/early windows)
// Orders by departure time ASC to get the EARLIEST matching trip (the one currently in progress)
func (q *Queries) GetActiveTripInBlockAtTime(ctx context.Context, arg GetActiveTripInBlockAtTimeParams) (string, error) {
	query := getActiveTripInBlockAtTime
	var queryParams []interface{}
	queryParams = append(queryParams, arg.BlockID)
	if len(arg.ServiceIds) > 0 {
		for _, v := range arg.ServiceIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:service_ids*/?", strings.Repeat(",?", len(arg.ServiceIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:service_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.CurrentTime)
	row := q.queryRow(ctx, nil, query, queryParams...)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getAgenciesForStops = `-- name: GetAgenciesForStops :many
SELECT DISTINCT
    a.id,
    a.name,
    a.url,
    a.timezone,
    a.lang,
    a.phone,
    a.fare_url,
    a.email,
    stop_times.stop_id
FROM
    stop_times
    JOIN trips ON stop_times.trip_id = trips.id
    JOIN routes ON trips.route_id = routes.id
    JOIN agencies a ON routes.agency_id = a.id
WHERE
    stop_times.stop_id IN (/*SLICE:stop_ids*/?)
`

type GetAgenciesForStopsRow struct {
	ID       string
	Name     string
	Url      string
	Timezone string
	Lang     sql.NullString
	Phone    sql.NullString
	FareUrl  sql.NullString
	Email    sql.NullString
	StopID   string
}

func (q *Queries) GetAgenciesForStops(ctx context.Context, stopIds []string) ([]GetAgenciesForStopsRow, error) {
	query := getAgenciesForStops
	var queryParams []interface{}
	if len(stopIds) > 0 {
		for _, v := range stopIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", strings.Repeat(",?", len(stopIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAgenciesForStopsRow
	for rows.Next() {
		var i GetAgenciesForStopsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Url,
			&i.Timezone,
			&i.Lang,
			&i.Phone,
			&i.FareUrl,
			&i.Email,
			&i.StopID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAgency = `-- name: GetAgency :one
SELECT
    id, name, url, timezone, lang, phone, fare_url, email
FROM
    agencies
WHERE
    id = ?
LIMIT
    1
`

func (q *Queries) GetAgency(ctx context.Context, id string) (Agency, error) {
	row := q.queryRow(ctx, q.getAgencyStmt, getAgency, id)
	var i Agency
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Timezone,
		&i.Lang,
		&i.Phone,
		&i.FareUrl,
		&i.Email,
	)
	return i, err
}

const getAgencyForStop = `-- name: GetAgencyForStop :one
SELECT DISTINCT
    a.id,
    a.name,
    a.url,
    a.timezone,
    a.lang,
    a.phone,
    a.fare_url,
    a.email
FROM
    agencies a
    JOIN routes r ON a.id = r.agency_id
    JOIN trips t ON r.id = t.route_id
    JOIN stop_times st ON t.id = st.trip_id
WHERE
    st.stop_id = ?
ORDER BY
    a.id
LIMIT
    1
`

func (q *Queries) GetAgencyForStop(ctx context.Context, stopID string) (Agency, error) {
	row := q.queryRow(ctx, q.getAgencyForStopStmt, getAgencyForStop, stopID)
	var i Agency
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Timezone,
		&i.Lang,
		&i.Phone,
		&i.FareUrl,
		&i.Email,
	)
	return i, err
}

const getAllShapes = `-- name: GetAllShapes :many
SELECT
    id, shape_id, lat, lon, shape_pt_sequence, shape_dist_traveled
FROM
    shapes
`

func (q *Queries) GetAllShapes(ctx context.Context) ([]Shape, error) {
	rows, err := q.query(ctx, q.getAllShapesStmt, getAllShapes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shape
	for rows.Next() {
		var i Shape
		if err := rows.Scan(
			&i.ID,
			&i.ShapeID,
			&i.Lat,
			&i.Lon,
			&i.ShapePtSequence,
			&i.ShapeDistTraveled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTripsForRoute = `-- name: GetAllTripsForRoute :many
SELECT DISTINCT id, route_id, service_id, trip_headsign, trip_short_name, direction_id, block_id, shape_id, wheelchair_accessible, bikes_allowed
FROM trips t
WHERE t.route_id = ?1
ORDER BY t.direction_id, t.trip_headsign
`

func (q *Queries) GetAllTripsForRoute(ctx context.Context, routeID string) ([]Trip, error) {
	rows, err := q.query(ctx, q.getAllTripsForRouteStmt, getAllTripsForRoute, routeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Trip
	for rows.Next() {
		var i Trip
		if err := rows.Scan(
			&i.ID,
			&i.RouteID,
			&i.ServiceID,
			&i.TripHeadsign,
			&i.TripShortName,
			&i.DirectionID,
			&i.BlockID,
			&i.ShapeID,
			&i.WheelchairAccessible,
			&i.BikesAllowed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArrivalsAndDeparturesForStop = `-- name: GetArrivalsAndDeparturesForStop :many
SELECT
    st.trip_id,
    st.arrival_time,
    st.departure_time,
    st.stop_sequence,
    st.stop_headsign,
    t.service_id,
    t.route_id,
    t.trip_headsign,
    t.block_id,
    r.id as route_id,
    r.agency_id,
    r.short_name as route_short_name,
    r.long_name as route_long_name
FROM
    stop_times st
        JOIN trips t ON st.trip_id = t.id
        JOIN routes r ON t.route_id = r.id
WHERE
    st.stop_id = ?
ORDER BY
    st.arrival_time LIMIT 50
`

type GetArrivalsAndDeparturesForStopRow struct {
	TripID         string
	ArrivalTime    int64
	DepartureTime  int64
	StopSequence   int64
	StopHeadsign   sql.NullString
	ServiceID      string
	RouteID        string
	TripHeadsign   sql.NullString
	BlockID        sql.NullString
	RouteID_2      string
	AgencyID       string
	RouteShortName sql.NullString
	RouteLongName  sql.NullString
}

func (q *Queries) GetArrivalsAndDeparturesForStop(ctx context.Context, stopID string) ([]GetArrivalsAndDeparturesForStopRow, error) {
	rows, err := q.query(ctx, q.getArrivalsAndDeparturesForStopStmt, getArrivalsAndDeparturesForStop, stopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetArrivalsAndDeparturesForStopRow
	for rows.Next() {
		var i GetArrivalsAndDeparturesForStopRow
		if err := rows.Scan(
			&i.TripID,
			&i.ArrivalTime,
			&i.DepartureTime,
			&i.StopSequence,
			&i.StopHeadsign,
			&i.ServiceID,
			&i.RouteID,
			&i.TripHeadsign,
			&i.BlockID,
			&i.RouteID_2,
			&i.AgencyID,
			&i.RouteShortName,
			&i.RouteLongName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockDetails = `-- name: GetBlockDetails :many
SELECT
    t.service_id,
    t.id as trip_id,
    t.route_id,
    st.arrival_time,
    st.departure_time,
    st.stop_id,
    st.stop_sequence,
    st.pickup_type,
    st.drop_off_type,
    s.lat,
    s.lon
FROM
    trips t
        JOIN
    stop_times st ON t.id = st.trip_id
        JOIN
    stops s ON st.stop_id = s.id
WHERE
    t.block_id = ?
ORDER BY
    t.id, st.stop_sequence
`

type GetBlockDetailsRow struct {
	ServiceID     string
	TripID        string
	RouteID       string
	ArrivalTime   int64
	DepartureTime int64
	StopID        string
	StopSequence  int64
	PickupType    sql.NullInt64
	DropOffType   sql.NullInt64
	Lat           float64
	Lon           float64
}

func (q *Queries) GetBlockDetails(ctx context.Context, blockID sql.NullString) ([]GetBlockDetailsRow, error) {
	rows, err := q.query(ctx, q.getBlockDetailsStmt, getBlockDetails, blockID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBlockDetailsRow
	for rows.Next() {
		var i GetBlockDetailsRow
		if err := rows.Scan(
			&i.ServiceID,
			&i.TripID,
			&i.RouteID,
			&i.ArrivalTime,
			&i.DepartureTime,
			&i.StopID,
			&i.StopSequence,
			&i.PickupType,
			&i.DropOffType,
			&i.Lat,
			&i.Lon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockIDByTripID = `-- name: GetBlockIDByTripID :one
SELECT
    block_id
FROM
    trips
WHERE
    id = ?
`

func (q *Queries) GetBlockIDByTripID(ctx context.Context, id string) (sql.NullString, error) {
	row := q.queryRow(ctx, q.getBlockIDByTripIDStmt, getBlockIDByTripID, id)
	var block_id sql.NullString
	err := row.Scan(&block_id)
	return block_id, err
}

const getBlockTripIndexIDsForBlocks = `-- name: GetBlockTripIndexIDsForBlocks :many
SELECT DISTINCT bte.block_trip_index_id
FROM block_trip_entry bte
WHERE bte.block_id IN (/*SLICE:block_ids*/?)
  AND bte.service_id IN (/*SLICE:service_ids*/?)
ORDER BY bte.block_trip_index_id
`

type GetBlockTripIndexIDsForBlocksParams struct {
	BlockIds   []sql.NullString
	ServiceIds []string
}

// Get all BlockTripIndex IDs that contain trips from the specified blocks
func (q *Queries) GetBlockTripIndexIDsForBlocks(ctx context.Context, arg GetBlockTripIndexIDsForBlocksParams) ([]int64, error) {
	query := getBlockTripIndexIDsForBlocks
	var queryParams []interface{}
	if len(arg.BlockIds) > 0 {
		for _, v := range arg.BlockIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:block_ids*/?", strings.Repeat(",?", len(arg.BlockIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:block_ids*/?", "NULL", 1)
	}
	if len(arg.ServiceIds) > 0 {
		for _, v := range arg.ServiceIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:service_ids*/?", strings.Repeat(",?", len(arg.ServiceIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:service_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var block_trip_index_id int64
		if err := rows.Scan(&block_trip_index_id); err != nil {
			return nil, err
		}
		items = append(items, block_trip_index_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockTripIndexIDsForRoute = `-- name: GetBlockTripIndexIDsForRoute :many
SELECT DISTINCT bti.id
FROM block_trip_index bti
JOIN block_trip_entry bte ON bti.id = bte.block_trip_index_id
JOIN trips t ON bte.trip_id = t.id
WHERE t.route_id = ?1
  AND bte.service_id IN (/*SLICE:service_ids*/?)
ORDER BY bti.id
`

type GetBlockTripIndexIDsForRouteParams struct {
	RouteID    string
	ServiceIds []string
}

// Get all block_trip_index IDs that contain trips for the specified route and service IDs
func (q *Queries) GetBlockTripIndexIDsForRoute(ctx context.Context, arg GetBlockTripIndexIDsForRouteParams) ([]int64, error) {
	query := getBlockTripIndexIDsForRoute
	var queryParams []interface{}
	queryParams = append(queryParams, arg.RouteID)
	if len(arg.ServiceIds) > 0 {
		for _, v := range arg.ServiceIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:service_ids*/?", strings.Repeat(",?", len(arg.ServiceIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:service_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlocksForBlockTripIndexIDs = `-- name: GetBlocksForBlockTripIndexIDs :many
SELECT DISTINCT bte.block_id
FROM block_trip_entry bte
WHERE bte.block_trip_index_id IN (/*SLICE:index_ids*/?)
  AND bte.service_id IN (/*SLICE:service_ids*/?)
  AND bte.block_id IS NOT NULL
`

type GetBlocksForBlockTripIndexIDsParams struct {
	IndexIds   []int64
	ServiceIds []string
}

// Get all distinct block_ids that have trips in the specified BlockTripIndex IDs
func (q *Queries) GetBlocksForBlockTripIndexIDs(ctx context.Context, arg GetBlocksForBlockTripIndexIDsParams) ([]sql.NullString, error) {
	query := getBlocksForBlockTripIndexIDs
	var queryParams []interface{}
	if len(arg.IndexIds) > 0 {
		for _, v := range arg.IndexIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:index_ids*/?", strings.Repeat(",?", len(arg.IndexIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:index_ids*/?", "NULL", 1)
	}
	if len(arg.ServiceIds) > 0 {
		for _, v := range arg.ServiceIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:service_ids*/?", strings.Repeat(",?", len(arg.ServiceIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:service_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var block_id sql.NullString
		if err := rows.Scan(&block_id); err != nil {
			return nil, err
		}
		items = append(items, block_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCalendarByServiceID = `-- name: GetCalendarByServiceID :one
SELECT
    id, monday, tuesday, wednesday, thursday, friday, saturday, sunday, start_date, end_date
FROM
    calendar
WHERE
    id = ?
`

func (q *Queries) GetCalendarByServiceID(ctx context.Context, id string) (Calendar, error) {
	row := q.queryRow(ctx, q.getCalendarByServiceIDStmt, getCalendarByServiceID, id)
	var i Calendar
	err := row.Scan(
		&i.ID,
		&i.Monday,
		&i.Tuesday,
		&i.Wednesday,
		&i.Thursday,
		&i.Friday,
		&i.Saturday,
		&i.Sunday,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const getCalendarDateExceptionsForServiceID = `-- name: GetCalendarDateExceptionsForServiceID :many
SELECT
    service_id, date, exception_type
FROM
    calendar_dates
WHERE
    service_id = ?
`

func (q *Queries) GetCalendarDateExceptionsForServiceID(ctx context.Context, serviceID string) ([]CalendarDate, error) {
	rows, err := q.query(ctx, q.getCalendarDateExceptionsForServiceIDStmt, getCalendarDateExceptionsForServiceID, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CalendarDate
	for rows.Next() {
		var i CalendarDate
		if err := rows.Scan(&i.ServiceID, &i.Date, &i.ExceptionType); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getImportMetadata = `-- name: GetImportMetadata :one
SELECT
    id, file_hash, import_time, file_source
FROM
    import_metadata
WHERE
    id = 1
`

func (q *Queries) GetImportMetadata(ctx context.Context) (ImportMetadatum, error) {
	row := q.queryRow(ctx, q.getImportMetadataStmt, getImportMetadata)
	var i ImportMetadatum
	err := row.Scan(
		&i.ID,
		&i.FileHash,
		&i.ImportTime,
		&i.FileSource,
	)
	return i, err
}

const getNextStopInTrip = `-- name: GetNextStopInTrip :one
SELECT stops.lat, stops.lon, stops.id
FROM stop_times
JOIN stops ON stops.id = stop_times.stop_id
WHERE stop_times.trip_id = ?
  AND stop_times.stop_sequence > ?
ORDER BY stop_times.stop_sequence ASC
LIMIT 1
`

type GetNextStopInTripParams struct {
	TripID       string
	StopSequence int64
}

type GetNextStopInTripRow struct {
	Lat float64
	Lon float64
	ID  string
}

func (q *Queries) GetNextStopInTrip(ctx context.Context, arg GetNextStopInTripParams) (GetNextStopInTripRow, error) {
	row := q.queryRow(ctx, q.getNextStopInTripStmt, getNextStopInTrip, arg.TripID, arg.StopSequence)
	var i GetNextStopInTripRow
	err := row.Scan(&i.Lat, &i.Lon, &i.ID)
	return i, err
}

const getOrderedStopIDsForTrip = `-- name: GetOrderedStopIDsForTrip :many
SELECT stop_id
FROM stop_times
WHERE trip_id = ?
ORDER BY stop_sequence
`

func (q *Queries) GetOrderedStopIDsForTrip(ctx context.Context, tripID string) ([]string, error) {
	rows, err := q.query(ctx, q.getOrderedStopIDsForTripStmt, getOrderedStopIDsForTrip, tripID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var stop_id string
		if err := rows.Scan(&stop_id); err != nil {
			return nil, err
		}
		items = append(items, stop_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoute = `-- name: GetRoute :one
SELECT
    id, agency_id, short_name, long_name, "desc", type, url, color, text_color, continuous_pickup, continuous_drop_off
FROM
    routes
WHERE
    id = ?
`

func (q *Queries) GetRoute(ctx context.Context, id string) (Route, error) {
	row := q.queryRow(ctx, q.getRouteStmt, getRoute, id)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.AgencyID,
		&i.ShortName,
		&i.LongName,
		&i.Desc,
		&i.Type,
		&i.Url,
		&i.Color,
		&i.TextColor,
		&i.ContinuousPickup,
		&i.ContinuousDropOff,
	)
	return i, err
}

const getRouteIDsForAgency = `-- name: GetRouteIDsForAgency :many
SELECT
    r.id
FROM
    routes r
    JOIN agencies a ON r.agency_id = a.id
WHERE
    a.id = ?
`

func (q *Queries) GetRouteIDsForAgency(ctx context.Context, id string) ([]string, error) {
	rows, err := q.query(ctx, q.getRouteIDsForAgencyStmt, getRouteIDsForAgency, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRouteIDsForStop = `-- name: GetRouteIDsForStop :many
SELECT DISTINCT
    (routes.agency_id || '_' || routes.id) AS route_id
FROM
    stop_times
    JOIN trips ON stop_times.trip_id = trips.id
    JOIN routes ON trips.route_id = routes.id
WHERE
    stop_times.stop_id = ?
`

func (q *Queries) GetRouteIDsForStop(ctx context.Context, stopID string) ([]interface{}, error) {
	rows, err := q.query(ctx, q.getRouteIDsForStopStmt, getRouteIDsForStop, stopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var route_id interface{}
		if err := rows.Scan(&route_id); err != nil {
			return nil, err
		}
		items = append(items, route_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRouteIDsForStops = `-- name: GetRouteIDsForStops :many
SELECT DISTINCT
    routes.agency_id || '_' || routes.id AS route_id,
    stop_times.stop_id
FROM
    stop_times
    JOIN trips ON stop_times.trip_id = trips.id
    JOIN routes ON trips.route_id = routes.id
WHERE
    stop_times.stop_id IN (/*SLICE:stop_ids*/?)
`

type GetRouteIDsForStopsRow struct {
	RouteID interface{}
	StopID  string
}

func (q *Queries) GetRouteIDsForStops(ctx context.Context, stopIds []string) ([]GetRouteIDsForStopsRow, error) {
	query := getRouteIDsForStops
	var queryParams []interface{}
	if len(stopIds) > 0 {
		for _, v := range stopIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", strings.Repeat(",?", len(stopIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRouteIDsForStopsRow
	for rows.Next() {
		var i GetRouteIDsForStopsRow
		if err := rows.Scan(&i.RouteID, &i.StopID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoutesByIDs = `-- name: GetRoutesByIDs :many
SELECT
    id, agency_id, short_name, long_name, "desc", type, url, color, text_color, continuous_pickup, continuous_drop_off
FROM
    routes
WHERE
    id IN (/*SLICE:route_ids*/?)
ORDER BY
    id
`

func (q *Queries) GetRoutesByIDs(ctx context.Context, routeIds []string) ([]Route, error) {
	query := getRoutesByIDs
	var queryParams []interface{}
	if len(routeIds) > 0 {
		for _, v := range routeIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:route_ids*/?", strings.Repeat(",?", len(routeIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:route_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Route
	for rows.Next() {
		var i Route
		if err := rows.Scan(
			&i.ID,
			&i.AgencyID,
			&i.ShortName,
			&i.LongName,
			&i.Desc,
			&i.Type,
			&i.Url,
			&i.Color,
			&i.TextColor,
			&i.ContinuousPickup,
			&i.ContinuousDropOff,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoutesForStop = `-- name: GetRoutesForStop :many
SELECT DISTINCT
    routes.id, routes.agency_id, routes.short_name, routes.long_name, routes."desc", routes.type, routes.url, routes.color, routes.text_color, routes.continuous_pickup, routes.continuous_drop_off
FROM
    stop_times
    JOIN trips ON stop_times.trip_id = trips.id
    JOIN routes ON trips.route_id = routes.id
WHERE
    stop_times.stop_id = ?
`

func (q *Queries) GetRoutesForStop(ctx context.Context, stopID string) ([]Route, error) {
	rows, err := q.query(ctx, q.getRoutesForStopStmt, getRoutesForStop, stopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Route
	for rows.Next() {
		var i Route
		if err := rows.Scan(
			&i.ID,
			&i.AgencyID,
			&i.ShortName,
			&i.LongName,
			&i.Desc,
			&i.Type,
			&i.Url,
			&i.Color,
			&i.TextColor,
			&i.ContinuousPickup,
			&i.ContinuousDropOff,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoutesForStops = `-- name: GetRoutesForStops :many

SELECT DISTINCT
    routes.id, routes.agency_id, routes.short_name, routes.long_name, routes."desc", routes.type, routes.url, routes.color, routes.text_color, routes.continuous_pickup, routes.continuous_drop_off,
    stop_times.stop_id
FROM
    stop_times
    JOIN trips ON stop_times.trip_id = trips.id
    JOIN routes ON trips.route_id = routes.id
WHERE
    stop_times.stop_id IN (/*SLICE:stop_ids*/?)
`

type GetRoutesForStopsRow struct {
	ID                string
	AgencyID          string
	ShortName         sql.NullString
	LongName          sql.NullString
	Desc              sql.NullString
	Type              int64
	Url               sql.NullString
	Color             sql.NullString
	TextColor         sql.NullString
	ContinuousPickup  sql.NullInt64
	ContinuousDropOff sql.NullInt64
	StopID            string
}

// Batch queries to solve N+1 problems
func (q *Queries) GetRoutesForStops(ctx context.Context, stopIds []string) ([]GetRoutesForStopsRow, error) {
	query := getRoutesForStops
	var queryParams []interface{}
	if len(stopIds) > 0 {
		for _, v := range stopIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", strings.Repeat(",?", len(stopIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoutesForStopsRow
	for rows.Next() {
		var i GetRoutesForStopsRow
		if err := rows.Scan(
			&i.ID,
			&i.AgencyID,
			&i.ShortName,
			&i.LongName,
			&i.Desc,
			&i.Type,
			&i.Url,
			&i.Color,
			&i.TextColor,
			&i.ContinuousPickup,
			&i.ContinuousDropOff,
			&i.StopID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoutesInBlockTripIndices = `-- name: GetRoutesInBlockTripIndices :many
SELECT DISTINCT t.route_id
FROM trips t
JOIN block_trip_entry bte ON t.id = bte.trip_id
WHERE bte.block_trip_index_id IN (/*SLICE:index_ids*/?)
  AND bte.service_id IN (/*SLICE:service_ids*/?)
`

type GetRoutesInBlockTripIndicesParams struct {
	IndexIds   []int64
	ServiceIds []string
}

// Get all unique route IDs that have trips in the specified block_trip_index IDs
func (q *Queries) GetRoutesInBlockTripIndices(ctx context.Context, arg GetRoutesInBlockTripIndicesParams) ([]string, error) {
	query := getRoutesInBlockTripIndices
	var queryParams []interface{}
	if len(arg.IndexIds) > 0 {
		for _, v := range arg.IndexIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:index_ids*/?", strings.Repeat(",?", len(arg.IndexIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:index_ids*/?", "NULL", 1)
	}
	if len(arg.ServiceIds) > 0 {
		for _, v := range arg.ServiceIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:service_ids*/?", strings.Repeat(",?", len(arg.ServiceIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:service_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var route_id string
		if err := rows.Scan(&route_id); err != nil {
			return nil, err
		}
		items = append(items, route_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScheduleForStop = `-- name: GetScheduleForStop :many
SELECT
    st.trip_id,
    st.arrival_time,
    st.departure_time,
    st.stop_headsign,
    t.service_id,
    t.route_id,
    t.trip_headsign,
    r.id as route_id,
    r.agency_id
FROM
    stop_times st
    JOIN trips t ON st.trip_id = t.id
    JOIN routes r ON t.route_id = r.id
WHERE
    st.stop_id = ?
ORDER BY
    r.id, st.arrival_time
`

type GetScheduleForStopRow struct {
	TripID        string
	ArrivalTime   int64
	DepartureTime int64
	StopHeadsign  sql.NullString
	ServiceID     string
	RouteID       string
	TripHeadsign  sql.NullString
	RouteID_2     string
	AgencyID      string
}

func (q *Queries) GetScheduleForStop(ctx context.Context, stopID string) ([]GetScheduleForStopRow, error) {
	rows, err := q.query(ctx, q.getScheduleForStopStmt, getScheduleForStop, stopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScheduleForStopRow
	for rows.Next() {
		var i GetScheduleForStopRow
		if err := rows.Scan(
			&i.TripID,
			&i.ArrivalTime,
			&i.DepartureTime,
			&i.StopHeadsign,
			&i.ServiceID,
			&i.RouteID,
			&i.TripHeadsign,
			&i.RouteID_2,
			&i.AgencyID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScheduleForStopOnDate = `-- name: GetScheduleForStopOnDate :many
SELECT
    st.trip_id,
    st.arrival_time,
    st.departure_time,
    st.stop_headsign,
    t.service_id,
    t.route_id,
    t.trip_headsign,
    r.id as route_id,
    r.agency_id
FROM
    stop_times st
    JOIN trips t ON st.trip_id = t.id
    JOIN routes r ON t.route_id = r.id
    LEFT JOIN (
        SELECT c.id AS service_id
        FROM calendar c
        WHERE c.start_date <= ?1
          AND c.end_date >= ?1
          AND (
            (?2 = 'sunday' AND c.sunday = 1) OR
            (?2 = 'monday' AND c.monday = 1) OR
            (?2 = 'tuesday' AND c.tuesday = 1) OR
            (?2 = 'wednesday' AND c.wednesday = 1) OR
            (?2 = 'thursday' AND c.thursday = 1) OR
            (?2 = 'friday' AND c.friday = 1) OR
            (?2 = 'saturday' AND c.saturday = 1)
          )
    ) base ON t.service_id = base.service_id
    LEFT JOIN (
        SELECT cd.service_id
        FROM calendar_dates cd
        WHERE cd.date = ?1 AND cd.exception_type = 2
    ) removed ON t.service_id = removed.service_id
    LEFT JOIN (
        SELECT cd.service_id
        FROM calendar_dates cd
        WHERE cd.date = ?1 AND cd.exception_type = 1
    ) added ON t.service_id = added.service_id
WHERE
    st.stop_id = ?3
    AND (
        (base.service_id IS NOT NULL AND removed.service_id IS NULL)
        OR
        added.service_id IS NOT NULL
    )
    AND r.id IN (/*SLICE:route_ids*/?)
ORDER BY
    r.id, st.arrival_time
`

type GetScheduleForStopOnDateParams struct {
	TargetDate string
	Weekday    interface{}
	StopID     string
	RouteIds   []string
}

type GetScheduleForStopOnDateRow struct {
	TripID        string
	ArrivalTime   int64
	DepartureTime int64
	StopHeadsign  sql.NullString
	ServiceID     string
	RouteID       string
	TripHeadsign  sql.NullString
	RouteID_2     string
	AgencyID      string
}

func (q *Queries) GetScheduleForStopOnDate(ctx context.Context, arg GetScheduleForStopOnDateParams) ([]GetScheduleForStopOnDateRow, error) {
	query := getScheduleForStopOnDate
	var queryParams []interface{}
	queryParams = append(queryParams, arg.TargetDate)
	queryParams = append(queryParams, arg.Weekday)
	queryParams = append(queryParams, arg.StopID)
	if len(arg.RouteIds) > 0 {
		for _, v := range arg.RouteIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:route_ids*/?", strings.Repeat(",?", len(arg.RouteIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:route_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScheduleForStopOnDateRow
	for rows.Next() {
		var i GetScheduleForStopOnDateRow
		if err := rows.Scan(
			&i.TripID,
			&i.ArrivalTime,
			&i.DepartureTime,
			&i.StopHeadsign,
			&i.ServiceID,
			&i.RouteID,
			&i.TripHeadsign,
			&i.RouteID_2,
			&i.AgencyID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShapeByID = `-- name: GetShapeByID :many
SELECT
    id, shape_id, lat, lon, shape_pt_sequence, shape_dist_traveled
FROM
    shapes
WHERE
    shape_id = ?
ORDER BY
    shape_pt_sequence
`

func (q *Queries) GetShapeByID(ctx context.Context, shapeID string) ([]Shape, error) {
	rows, err := q.query(ctx, q.getShapeByIDStmt, getShapeByID, shapeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shape
	for rows.Next() {
		var i Shape
		if err := rows.Scan(
			&i.ID,
			&i.ShapeID,
			&i.Lat,
			&i.Lon,
			&i.ShapePtSequence,
			&i.ShapeDistTraveled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShapePointWindow = `-- name: GetShapePointWindow :many
SELECT lat, lon, shape_pt_sequence, shape_dist_traveled
FROM shapes
WHERE shape_id = ?
  AND shape_pt_sequence BETWEEN ? AND ?
ORDER BY shape_pt_sequence
`

type GetShapePointWindowRow struct {
	Lat               float64
	Lon               float64
	ShapePtSequence   int64
	ShapeDistTraveled sql.NullFloat64
}

func (q *Queries) GetShapePointWindow(ctx context.Context, shapeID string) ([]GetShapePointWindowRow, error) {
	rows, err := q.query(ctx, q.getShapePointWindowStmt, getShapePointWindow, shapeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetShapePointWindowRow
	for rows.Next() {
		var i GetShapePointWindowRow
		if err := rows.Scan(
			&i.Lat,
			&i.Lon,
			&i.ShapePtSequence,
			&i.ShapeDistTraveled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShapePointsByIDs = `-- name: GetShapePointsByIDs :many
SELECT shape_id, lat, lon, shape_pt_sequence, shape_dist_traveled
FROM shapes
WHERE shape_id IN (/*SLICE:shape_ids*/?)
ORDER BY shape_id, shape_pt_sequence
`

type GetShapePointsByIDsRow struct {
	ShapeID           string
	Lat               float64
	Lon               float64
	ShapePtSequence   int64
	ShapeDistTraveled sql.NullFloat64
}

func (q *Queries) GetShapePointsByIDs(ctx context.Context, shapeIds []string) ([]GetShapePointsByIDsRow, error) {
	query := getShapePointsByIDs
	var queryParams []interface{}
	if len(shapeIds) > 0 {
		for _, v := range shapeIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:shape_ids*/?", strings.Repeat(",?", len(shapeIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:shape_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetShapePointsByIDsRow
	for rows.Next() {
		var i GetShapePointsByIDsRow
		if err := rows.Scan(
			&i.ShapeID,
			&i.Lat,
			&i.Lon,
			&i.ShapePtSequence,
			&i.ShapeDistTraveled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShapePointsByTripID = `-- name: GetShapePointsByTripID :many
SELECT
    s.id,
    s.shape_id,
    s.lat,
    s.lon,
    s.shape_pt_sequence,
    s.shape_dist_traveled
FROM
    shapes s
    JOIN trips t ON t.shape_id = s.shape_id
WHERE
    t.id = ?
ORDER BY
    s.shape_pt_sequence ASC
`

func (q *Queries) GetShapePointsByTripID(ctx context.Context, id string) ([]Shape, error) {
	rows, err := q.query(ctx, q.getShapePointsByTripIDStmt, getShapePointsByTripID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shape
	for rows.Next() {
		var i Shape
		if err := rows.Scan(
			&i.ID,
			&i.ShapeID,
			&i.Lat,
			&i.Lon,
			&i.ShapePtSequence,
			&i.ShapeDistTraveled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShapePointsForTrip = `-- name: GetShapePointsForTrip :many
SELECT DISTINCT shapes.lat, shapes.lon, shapes.shape_pt_sequence
FROM shapes
JOIN trips ON trips.shape_id = shapes.shape_id
WHERE trips.id = ?
ORDER BY shapes.shape_pt_sequence
`

type GetShapePointsForTripRow struct {
	Lat             float64
	Lon             float64
	ShapePtSequence int64
}

func (q *Queries) GetShapePointsForTrip(ctx context.Context, id string) ([]GetShapePointsForTripRow, error) {
	rows, err := q.query(ctx, q.getShapePointsForTripStmt, getShapePointsForTrip, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetShapePointsForTripRow
	for rows.Next() {
		var i GetShapePointsForTripRow
		if err := rows.Scan(&i.Lat, &i.Lon, &i.ShapePtSequence); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShapePointsWithDistance = `-- name: GetShapePointsWithDistance :many
SELECT lat, lon, shape_pt_sequence, shape_dist_traveled
FROM shapes
WHERE shape_id = ?
ORDER BY shape_pt_sequence
`

type GetShapePointsWithDistanceRow struct {
	Lat               float64
	Lon               float64
	ShapePtSequence   int64
	ShapeDistTraveled sql.NullFloat64
}

func (q *Queries) GetShapePointsWithDistance(ctx context.Context, shapeID string) ([]GetShapePointsWithDistanceRow, error) {
	rows, err := q.query(ctx, q.getShapePointsWithDistanceStmt, getShapePointsWithDistance, shapeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetShapePointsWithDistanceRow
	for rows.Next() {
		var i GetShapePointsWithDistanceRow
		if err := rows.Scan(
			&i.Lat,
			&i.Lon,
			&i.ShapePtSequence,
			&i.ShapeDistTraveled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShapesGroupedByTripHeadSign = `-- name: GetShapesGroupedByTripHeadSign :many
SELECT DISTINCT s.lat, s.lon, s.shape_pt_sequence
FROM shapes s
         JOIN (
    SELECT shape_id
    FROM trips
    WHERE route_id = ?1
      AND trip_headsign = ?2
      AND shape_id IS NOT NULL
    LIMIT 1
) t ON s.shape_id = t.shape_id
ORDER BY s.shape_pt_sequence
`

type GetShapesGroupedByTripHeadSignParams struct {
	RouteID      string
	TripHeadsign sql.NullString
}

type GetShapesGroupedByTripHeadSignRow struct {
	Lat             float64
	Lon             float64
	ShapePtSequence int64
}

func (q *Queries) GetShapesGroupedByTripHeadSign(ctx context.Context, arg GetShapesGroupedByTripHeadSignParams) ([]GetShapesGroupedByTripHeadSignRow, error) {
	rows, err := q.query(ctx, q.getShapesGroupedByTripHeadSignStmt, getShapesGroupedByTripHeadSign, arg.RouteID, arg.TripHeadsign)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetShapesGroupedByTripHeadSignRow
	for rows.Next() {
		var i GetShapesGroupedByTripHeadSignRow
		if err := rows.Scan(&i.Lat, &i.Lon, &i.ShapePtSequence); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStop = `-- name: GetStop :one
SELECT
    id,
    code,
    name,
    desc,
    lat,
    lon,
    zone_id,
    url,
    location_type,
    timezone,
    wheelchair_boarding,
    platform_code,
    direction
FROM
    stops
WHERE
    id = ?
LIMIT
    1
`

type GetStopRow struct {
	ID                 string
	Code               sql.NullString
	Name               sql.NullString
	Desc               sql.NullString
	Lat                float64
	Lon                float64
	ZoneID             sql.NullString
	Url                sql.NullString
	LocationType       sql.NullInt64
	Timezone           sql.NullString
	WheelchairBoarding sql.NullInt64
	PlatformCode       sql.NullString
	Direction          sql.NullString
}

func (q *Queries) GetStop(ctx context.Context, id string) (GetStopRow, error) {
	row := q.queryRow(ctx, q.getStopStmt, getStop, id)
	var i GetStopRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Desc,
		&i.Lat,
		&i.Lon,
		&i.ZoneID,
		&i.Url,
		&i.LocationType,
		&i.Timezone,
		&i.WheelchairBoarding,
		&i.PlatformCode,
		&i.Direction,
	)
	return i, err
}

const getStopForAgency = `-- name: GetStopForAgency :one
SELECT DISTINCT
    stops.id, stops.code, stops.name, stops."desc", stops.lat, stops.lon, stops.zone_id, stops.url, stops.location_type, stops.timezone, stops.wheelchair_boarding, stops.platform_code, stops.direction, stops.parent_station
FROM
    stops
    JOIN stop_times ON stops.id = stop_times.stop_id
    JOIN trips ON stop_times.trip_id = trips.id
    JOIN routes ON trips.route_id = routes.id
WHERE
    stops.id = ?
    AND routes.agency_id = ?
`

type GetStopForAgencyParams struct {
	ID       string
	AgencyID string
}

// Return the stop only if it is served by any route that belongs to the specified agency.
// We join stop_times -> trips -> routes and filter by routes.agency_id to enforce agency ownership.
func (q *Queries) GetStopForAgency(ctx context.Context, arg GetStopForAgencyParams) (Stop, error) {
	row := q.queryRow(ctx, q.getStopForAgencyStmt, getStopForAgency, arg.ID, arg.AgencyID)
	var i Stop
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Desc,
		&i.Lat,
		&i.Lon,
		&i.ZoneID,
		&i.Url,
		&i.LocationType,
		&i.Timezone,
		&i.WheelchairBoarding,
		&i.PlatformCode,
		&i.Direction,
		&i.ParentStation,
	)
	return i, err
}

const getStopIDsForAgency = `-- name: GetStopIDsForAgency :many
SELECT DISTINCT
    s.id
FROM
    stops s
    JOIN stop_times st ON s.id = st.stop_id
    JOIN trips t ON st.trip_id = t.id
    JOIN routes r ON t.route_id = r.id
WHERE
    r.agency_id = ?
`

func (q *Queries) GetStopIDsForAgency(ctx context.Context, agencyID string) ([]string, error) {
	rows, err := q.query(ctx, q.getStopIDsForAgencyStmt, getStopIDsForAgency, agencyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStopIDsForRoute = `-- name: GetStopIDsForRoute :many
SELECT DISTINCT
    stop_times.stop_id
FROM
    stop_times
        JOIN trips ON stop_times.trip_id = trips.id
WHERE
    trips.route_id = ?
`

func (q *Queries) GetStopIDsForRoute(ctx context.Context, routeID string) ([]string, error) {
	rows, err := q.query(ctx, q.getStopIDsForRouteStmt, getStopIDsForRoute, routeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var stop_id string
		if err := rows.Scan(&stop_id); err != nil {
			return nil, err
		}
		items = append(items, stop_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStopIDsForTrip = `-- name: GetStopIDsForTrip :many
SELECT DISTINCT
    stop_times.stop_id
FROM
    stop_times
WHERE
    stop_times.trip_id = ?
`

func (q *Queries) GetStopIDsForTrip(ctx context.Context, tripID string) ([]string, error) {
	rows, err := q.query(ctx, q.getStopIDsForTripStmt, getStopIDsForTrip, tripID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var stop_id string
		if err := rows.Scan(&stop_id); err != nil {
			return nil, err
		}
		items = append(items, stop_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStopTimesByStopIDs = `-- name: GetStopTimesByStopIDs :many
SELECT
    trip_id, arrival_time, departure_time, stop_id, stop_sequence, stop_headsign, pickup_type, drop_off_type, shape_dist_traveled, timepoint
FROM
    stop_times
WHERE
    stop_id IN (/*SLICE:stop_ids*/?)
`

func (q *Queries) GetStopTimesByStopIDs(ctx context.Context, stopIds []string) ([]StopTime, error) {
	query := getStopTimesByStopIDs
	var queryParams []interface{}
	if len(stopIds) > 0 {
		for _, v := range stopIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", strings.Repeat(",?", len(stopIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StopTime
	for rows.Next() {
		var i StopTime
		if err := rows.Scan(
			&i.TripID,
			&i.ArrivalTime,
			&i.DepartureTime,
			&i.StopID,
			&i.StopSequence,
			&i.StopHeadsign,
			&i.PickupType,
			&i.DropOffType,
			&i.ShapeDistTraveled,
			&i.Timepoint,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStopTimesForStopInWindow = `-- name: GetStopTimesForStopInWindow :many
SELECT
    st.trip_id, st.arrival_time, st.departure_time, st.stop_id, st.stop_sequence, st.stop_headsign, st.pickup_type, st.drop_off_type, st.shape_dist_traveled, st.timepoint,
    t.route_id,
    t.service_id,
    t.trip_headsign,
    t.block_id
FROM stop_times st
         JOIN trips t ON st.trip_id = t.id
WHERE st.stop_id = ?1
  AND (
    (st.arrival_time BETWEEN ?2 AND ?3)
        OR
    (st.departure_time BETWEEN ?2 AND ?3)
    )
ORDER BY st.arrival_time
`

type GetStopTimesForStopInWindowParams struct {
	StopID           string
	WindowStartNanos int64
	WindowEndNanos   int64
}

type GetStopTimesForStopInWindowRow struct {
	TripID            string
	ArrivalTime       int64
	DepartureTime     int64
	StopID            string
	StopSequence      int64
	StopHeadsign      sql.NullString
	PickupType        sql.NullInt64
	DropOffType       sql.NullInt64
	ShapeDistTraveled sql.NullFloat64
	Timepoint         sql.NullInt64
	RouteID           string
	ServiceID         string
	TripHeadsign      sql.NullString
	BlockID           sql.NullString
}

func (q *Queries) GetStopTimesForStopInWindow(ctx context.Context, arg GetStopTimesForStopInWindowParams) ([]GetStopTimesForStopInWindowRow, error) {
	rows, err := q.query(ctx, q.getStopTimesForStopInWindowStmt, getStopTimesForStopInWindow, arg.StopID, arg.WindowStartNanos, arg.WindowEndNanos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStopTimesForStopInWindowRow
	for rows.Next() {
		var i GetStopTimesForStopInWindowRow
		if err := rows.Scan(
			&i.TripID,
			&i.ArrivalTime,
			&i.DepartureTime,
			&i.StopID,
			&i.StopSequence,
			&i.StopHeadsign,
			&i.PickupType,
			&i.DropOffType,
			&i.ShapeDistTraveled,
			&i.Timepoint,
			&i.RouteID,
			&i.ServiceID,
			&i.TripHeadsign,
			&i.BlockID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStopTimesForTrip = `-- name: GetStopTimesForTrip :many
SELECT
    trip_id, arrival_time, departure_time, stop_id, stop_sequence, stop_headsign, pickup_type, drop_off_type, shape_dist_traveled, timepoint
FROM
    stop_times
WHERE
    trip_id = ?
ORDER BY
    stop_sequence
`

func (q *Queries) GetStopTimesForTrip(ctx context.Context, tripID string) ([]StopTime, error) {
	rows, err := q.query(ctx, q.getStopTimesForTripStmt, getStopTimesForTrip, tripID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StopTime
	for rows.Next() {
		var i StopTime
		if err := rows.Scan(
			&i.TripID,
			&i.ArrivalTime,
			&i.DepartureTime,
			&i.StopID,
			&i.StopSequence,
			&i.StopHeadsign,
			&i.PickupType,
			&i.DropOffType,
			&i.ShapeDistTraveled,
			&i.Timepoint,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStopTimesForTripIDs = `-- name: GetStopTimesForTripIDs :many
SELECT trip_id, arrival_time, departure_time, stop_id, stop_sequence, stop_headsign, pickup_type, drop_off_type, shape_dist_traveled, timepoint FROM stop_times
WHERE trip_id IN (/*SLICE:trip_ids*/?)
ORDER BY trip_id, stop_sequence
`

func (q *Queries) GetStopTimesForTripIDs(ctx context.Context, tripIds []string) ([]StopTime, error) {
	query := getStopTimesForTripIDs
	var queryParams []interface{}
	if len(tripIds) > 0 {
		for _, v := range tripIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:trip_ids*/?", strings.Repeat(",?", len(tripIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:trip_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StopTime
	for rows.Next() {
		var i StopTime
		if err := rows.Scan(
			&i.TripID,
			&i.ArrivalTime,
			&i.DepartureTime,
			&i.StopID,
			&i.StopSequence,
			&i.StopHeadsign,
			&i.PickupType,
			&i.DropOffType,
			&i.ShapeDistTraveled,
			&i.Timepoint,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStopsByIDs = `-- name: GetStopsByIDs :many
SELECT
    id, code, name, "desc", lat, lon, zone_id, url, location_type, timezone, wheelchair_boarding, platform_code, direction, parent_station
FROM
    stops
WHERE
    id IN (/*SLICE:stop_ids*/?)
ORDER BY
    id
`

func (q *Queries) GetStopsByIDs(ctx context.Context, stopIds []string) ([]Stop, error) {
	query := getStopsByIDs
	var queryParams []interface{}
	if len(stopIds) > 0 {
		for _, v := range stopIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", strings.Repeat(",?", len(stopIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stop
	for rows.Next() {
		var i Stop
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Desc,
			&i.Lat,
			&i.Lon,
			&i.ZoneID,
			&i.Url,
			&i.LocationType,
			&i.Timezone,
			&i.WheelchairBoarding,
			&i.PlatformCode,
			&i.Direction,
			&i.ParentStation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStopsForRoute = `-- name: GetStopsForRoute :many
SELECT DISTINCT
    stops.id, stops.code, stops.name, stops."desc", stops.lat, stops.lon, stops.zone_id, stops.url, stops.location_type, stops.timezone, stops.wheelchair_boarding, stops.platform_code, stops.direction, stops.parent_station
FROM
    stop_times
    JOIN trips ON stop_times.trip_id = trips.id
    JOIN routes ON trips.route_id = routes.id
    JOIN stops ON stop_times.stop_id = stops.id
WHERE
    routes.id = ?
`

func (q *Queries) GetStopsForRoute(ctx context.Context, id string) ([]Stop, error) {
	rows, err := q.query(ctx, q.getStopsForRouteStmt, getStopsForRoute, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stop
	for rows.Next() {
		var i Stop
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Desc,
			&i.Lat,
			&i.Lon,
			&i.ZoneID,
			&i.Url,
			&i.LocationType,
			&i.Timezone,
			&i.WheelchairBoarding,
			&i.PlatformCode,
			&i.Direction,
			&i.ParentStation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStopsWithActiveServiceOnDate = `-- name: GetStopsWithActiveServiceOnDate :many
SELECT DISTINCT st.stop_id
FROM stop_times st
JOIN trips t ON st.trip_id = t.id
WHERE st.stop_id IN (/*SLICE:stop_ids*/?)
  AND t.service_id IN (/*SLICE:service_ids*/?)
`

type GetStopsWithActiveServiceOnDateParams struct {
	StopIds    []string
	ServiceIds []string
}

// Returns stop IDs that have at least one trip with active service on the given date
func (q *Queries) GetStopsWithActiveServiceOnDate(ctx context.Context, arg GetStopsWithActiveServiceOnDateParams) ([]string, error) {
	query := getStopsWithActiveServiceOnDate
	var queryParams []interface{}
	if len(arg.StopIds) > 0 {
		for _, v := range arg.StopIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", strings.Repeat(",?", len(arg.StopIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", "NULL", 1)
	}
	if len(arg.ServiceIds) > 0 {
		for _, v := range arg.ServiceIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:service_ids*/?", strings.Repeat(",?", len(arg.ServiceIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:service_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var stop_id string
		if err := rows.Scan(&stop_id); err != nil {
			return nil, err
		}
		items = append(items, stop_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStopsWithShapeContext = `-- name: GetStopsWithShapeContext :many
SELECT
    s.id, s.lat, s.lon, s.name, s.code, s.direction,
    st.trip_id, st.stop_sequence, st.shape_dist_traveled,
    t.shape_id
FROM stops s
JOIN stop_times st ON s.id = st.stop_id
JOIN trips t ON st.trip_id = t.id
WHERE s.id = ?
`

type GetStopsWithShapeContextRow struct {
	ID                string
	Lat               float64
	Lon               float64
	Name              sql.NullString
	Code              sql.NullString
	Direction         sql.NullString
	TripID            string
	StopSequence      int64
	ShapeDistTraveled sql.NullFloat64
	ShapeID           sql.NullString
}

func (q *Queries) GetStopsWithShapeContext(ctx context.Context, id string) ([]GetStopsWithShapeContextRow, error) {
	rows, err := q.query(ctx, q.getStopsWithShapeContextStmt, getStopsWithShapeContext, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStopsWithShapeContextRow
	for rows.Next() {
		var i GetStopsWithShapeContextRow
		if err := rows.Scan(
			&i.ID,
			&i.Lat,
			&i.Lon,
			&i.Name,
			&i.Code,
			&i.Direction,
			&i.TripID,
			&i.StopSequence,
			&i.ShapeDistTraveled,
			&i.ShapeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStopsWithShapeContextByIDs = `-- name: GetStopsWithShapeContextByIDs :many
SELECT 
    st.stop_id, 
    t.shape_id, 
    s.lat, 
    s.lon, 
    st.shape_dist_traveled
FROM stop_times st
JOIN trips t ON st.trip_id = t.id
JOIN stops s ON st.stop_id = s.id
WHERE st.stop_id IN (/*SLICE:stop_ids*/?)
`

type GetStopsWithShapeContextByIDsRow struct {
	StopID            string
	ShapeID           sql.NullString
	Lat               float64
	Lon               float64
	ShapeDistTraveled sql.NullFloat64
}

func (q *Queries) GetStopsWithShapeContextByIDs(ctx context.Context, stopIds []string) ([]GetStopsWithShapeContextByIDsRow, error) {
	query := getStopsWithShapeContextByIDs
	var queryParams []interface{}
	if len(stopIds) > 0 {
		for _, v := range stopIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", strings.Repeat(",?", len(stopIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStopsWithShapeContextByIDsRow
	for rows.Next() {
		var i GetStopsWithShapeContextByIDsRow
		if err := rows.Scan(
			&i.StopID,
			&i.ShapeID,
			&i.Lat,
			&i.Lon,
			&i.ShapeDistTraveled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStopsWithTripContext = `-- name: GetStopsWithTripContext :many
SELECT
    s.id, s.lat, s.lon, s.name, s.code,
    st.trip_id, st.stop_sequence,
    t.shape_id
FROM stops s
JOIN stop_times st ON s.id = st.stop_id
JOIN trips t ON st.trip_id = t.id
WHERE s.id = ?
`

type GetStopsWithTripContextRow struct {
	ID           string
	Lat          float64
	Lon          float64
	Name         sql.NullString
	Code         sql.NullString
	TripID       string
	StopSequence int64
	ShapeID      sql.NullString
}

func (q *Queries) GetStopsWithTripContext(ctx context.Context, id string) ([]GetStopsWithTripContextRow, error) {
	rows, err := q.query(ctx, q.getStopsWithTripContextStmt, getStopsWithTripContext, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStopsWithTripContextRow
	for rows.Next() {
		var i GetStopsWithTripContextRow
		if err := rows.Scan(
			&i.ID,
			&i.Lat,
			&i.Lon,
			&i.Name,
			&i.Code,
			&i.TripID,
			&i.StopSequence,
			&i.ShapeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrip = `-- name: GetTrip :one
SELECT
    id, route_id, service_id, trip_headsign, trip_short_name, direction_id, block_id, shape_id, wheelchair_accessible, bikes_allowed
FROM
    trips
WHERE
    id = ?
`

func (q *Queries) GetTrip(ctx context.Context, id string) (Trip, error) {
	row := q.queryRow(ctx, q.getTripStmt, getTrip, id)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.RouteID,
		&i.ServiceID,
		&i.TripHeadsign,
		&i.TripShortName,
		&i.DirectionID,
		&i.BlockID,
		&i.ShapeID,
		&i.WheelchairAccessible,
		&i.BikesAllowed,
	)
	return i, err
}

const getTripsByBlockID = `-- name: GetTripsByBlockID :many
SELECT
    id,
    route_id,
    service_id,
    trip_headsign,
    trip_short_name,
    direction_id,
    block_id,
    shape_id
FROM
    trips
WHERE
    block_id = ?
`

type GetTripsByBlockIDRow struct {
	ID            string
	RouteID       string
	ServiceID     string
	TripHeadsign  sql.NullString
	TripShortName sql.NullString
	DirectionID   sql.NullInt64
	BlockID       sql.NullString
	ShapeID       sql.NullString
}

func (q *Queries) GetTripsByBlockID(ctx context.Context, blockID sql.NullString) ([]GetTripsByBlockIDRow, error) {
	rows, err := q.query(ctx, q.getTripsByBlockIDStmt, getTripsByBlockID, blockID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTripsByBlockIDRow
	for rows.Next() {
		var i GetTripsByBlockIDRow
		if err := rows.Scan(
			&i.ID,
			&i.RouteID,
			&i.ServiceID,
			&i.TripHeadsign,
			&i.TripShortName,
			&i.DirectionID,
			&i.BlockID,
			&i.ShapeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTripsByBlockIDOrdered = `-- name: GetTripsByBlockIDOrdered :many
SELECT
    t.id,
    t.block_id,
    t.service_id,
    MIN(st.departure_time) AS first_departure_time,
    MAX(st.arrival_time) AS last_arrival_time
FROM
    trips t
    JOIN stop_times st ON st.trip_id = t.id
WHERE
    t.block_id = ?
    AND t.service_id IN (/*SLICE:service_ids*/?)
GROUP BY
    t.id,
    t.block_id,
    t.service_id
ORDER BY
    MIN(st.departure_time)
`

type GetTripsByBlockIDOrderedParams struct {
	BlockID    sql.NullString
	ServiceIds []string
}

type GetTripsByBlockIDOrderedRow struct {
	ID                 string
	BlockID            sql.NullString
	ServiceID          string
	FirstDepartureTime interface{}
	LastArrivalTime    interface{}
}

func (q *Queries) GetTripsByBlockIDOrdered(ctx context.Context, arg GetTripsByBlockIDOrderedParams) ([]GetTripsByBlockIDOrderedRow, error) {
	query := getTripsByBlockIDOrdered
	var queryParams []interface{}
	queryParams = append(queryParams, arg.BlockID)
	if len(arg.ServiceIds) > 0 {
		for _, v := range arg.ServiceIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:service_ids*/?", strings.Repeat(",?", len(arg.ServiceIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:service_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTripsByBlockIDOrderedRow
	for rows.Next() {
		var i GetTripsByBlockIDOrderedRow
		if err := rows.Scan(
			&i.ID,
			&i.BlockID,
			&i.ServiceID,
			&i.FirstDepartureTime,
			&i.LastArrivalTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTripsByBlockIDs = `-- name: GetTripsByBlockIDs :many
SELECT t.id, t.route_id, t.service_id, t.trip_headsign, t.trip_short_name, t.direction_id, t.block_id, t.shape_id, t.wheelchair_accessible, t.bikes_allowed
FROM trips t
JOIN stop_times st ON t.id = st.trip_id
WHERE t.block_id IN (/*SLICE:block_ids*/?)
  AND t.service_id IN (/*SLICE:service_ids*/?)
GROUP BY t.id
ORDER BY t.block_id, MIN(st.departure_time), t.id
`

type GetTripsByBlockIDsParams struct {
	BlockIds   []sql.NullString
	ServiceIds []string
}

func (q *Queries) GetTripsByBlockIDs(ctx context.Context, arg GetTripsByBlockIDsParams) ([]Trip, error) {
	query := getTripsByBlockIDs
	var queryParams []interface{}
	if len(arg.BlockIds) > 0 {
		for _, v := range arg.BlockIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:block_ids*/?", strings.Repeat(",?", len(arg.BlockIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:block_ids*/?", "NULL", 1)
	}
	if len(arg.ServiceIds) > 0 {
		for _, v := range arg.ServiceIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:service_ids*/?", strings.Repeat(",?", len(arg.ServiceIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:service_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Trip
	for rows.Next() {
		var i Trip
		if err := rows.Scan(
			&i.ID,
			&i.RouteID,
			&i.ServiceID,
			&i.TripHeadsign,
			&i.TripShortName,
			&i.DirectionID,
			&i.BlockID,
			&i.ShapeID,
			&i.WheelchairAccessible,
			&i.BikesAllowed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTripsByBlockTripIndexIDs = `-- name: GetTripsByBlockTripIndexIDs :many
SELECT DISTINCT
    t.id, t.route_id, t.service_id, t.trip_headsign, t.trip_short_name,
    t.direction_id, t.block_id, t.shape_id, t.wheelchair_accessible, t.bikes_allowed,
    bte.block_trip_sequence
FROM trips t
JOIN block_trip_entry bte ON t.id = bte.trip_id
WHERE bte.block_trip_index_id IN (/*SLICE:index_ids*/?)
  AND bte.service_id IN (/*SLICE:service_ids*/?)
  AND EXISTS (
    -- Check if trip could be active: maxDeparture >= timeFrom AND minArrival <= timeTo
    SELECT 1
    FROM stop_times st
    WHERE st.trip_id = t.id
    GROUP BY st.trip_id
    HAVING MAX(st.departure_time) >= ?3
       AND MIN(st.arrival_time) <= ?4
  )
ORDER BY t.route_id, bte.block_trip_sequence, t.id
`

type GetTripsByBlockTripIndexIDsParams struct {
	IndexIds   []int64
	ServiceIds []string
	FromTime   int64
	ToTime     int64
}

type GetTripsByBlockTripIndexIDsRow struct {
	ID                   string
	RouteID              string
	ServiceID            string
	TripHeadsign         sql.NullString
	TripShortName        sql.NullString
	DirectionID          sql.NullInt64
	BlockID              sql.NullString
	ShapeID              sql.NullString
	WheelchairAccessible sql.NullInt64
	BikesAllowed         sql.NullInt64
	BlockTripSequence    int64
}

// Get all trips that belong to the specified block_trip_index IDs within a time window
// Matches Java's findBlockTripsInRange logic using binary search on maxDepartures and minArrivals
// A trip is active if: maxDeparture >= timeFrom (could have started) AND minArrival <= timeTo (could still be active)
func (q *Queries) GetTripsByBlockTripIndexIDs(ctx context.Context, arg GetTripsByBlockTripIndexIDsParams) ([]GetTripsByBlockTripIndexIDsRow, error) {
	query := getTripsByBlockTripIndexIDs
	var queryParams []interface{}
	if len(arg.IndexIds) > 0 {
		for _, v := range arg.IndexIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:index_ids*/?", strings.Repeat(",?", len(arg.IndexIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:index_ids*/?", "NULL", 1)
	}
	if len(arg.ServiceIds) > 0 {
		for _, v := range arg.ServiceIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:service_ids*/?", strings.Repeat(",?", len(arg.ServiceIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:service_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.FromTime)
	queryParams = append(queryParams, arg.ToTime)
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTripsByBlockTripIndexIDsRow
	for rows.Next() {
		var i GetTripsByBlockTripIndexIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.RouteID,
			&i.ServiceID,
			&i.TripHeadsign,
			&i.TripShortName,
			&i.DirectionID,
			&i.BlockID,
			&i.ShapeID,
			&i.WheelchairAccessible,
			&i.BikesAllowed,
			&i.BlockTripSequence,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTripsByIDs = `-- name: GetTripsByIDs :many
SELECT
    id, route_id, service_id, trip_headsign, trip_short_name, direction_id, block_id, shape_id, wheelchair_accessible, bikes_allowed
FROM
    trips
WHERE
    id IN (/*SLICE:trip_ids*/?)
ORDER BY
    id
`

func (q *Queries) GetTripsByIDs(ctx context.Context, tripIds []string) ([]Trip, error) {
	query := getTripsByIDs
	var queryParams []interface{}
	if len(tripIds) > 0 {
		for _, v := range tripIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:trip_ids*/?", strings.Repeat(",?", len(tripIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:trip_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Trip
	for rows.Next() {
		var i Trip
		if err := rows.Scan(
			&i.ID,
			&i.RouteID,
			&i.ServiceID,
			&i.TripHeadsign,
			&i.TripShortName,
			&i.DirectionID,
			&i.BlockID,
			&i.ShapeID,
			&i.WheelchairAccessible,
			&i.BikesAllowed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTripsByServiceID = `-- name: GetTripsByServiceID :many
SELECT id, route_id, service_id, trip_headsign
FROM trips
WHERE service_id IN (/*SLICE:service_ids*/?)
`

type GetTripsByServiceIDRow struct {
	ID           string
	RouteID      string
	ServiceID    string
	TripHeadsign sql.NullString
}

func (q *Queries) GetTripsByServiceID(ctx context.Context, serviceIds []string) ([]GetTripsByServiceIDRow, error) {
	query := getTripsByServiceID
	var queryParams []interface{}
	if len(serviceIds) > 0 {
		for _, v := range serviceIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:service_ids*/?", strings.Repeat(",?", len(serviceIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:service_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTripsByServiceIDRow
	for rows.Next() {
		var i GetTripsByServiceIDRow
		if err := rows.Scan(
			&i.ID,
			&i.RouteID,
			&i.ServiceID,
			&i.TripHeadsign,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTripsForRouteInActiveServiceIDs = `-- name: GetTripsForRouteInActiveServiceIDs :many
SELECT DISTINCT id, route_id, service_id, trip_headsign, trip_short_name, direction_id, block_id, shape_id, wheelchair_accessible, bikes_allowed
FROM trips t
WHERE t.route_id = ?1
  AND t.service_id IN (/*SLICE:('service_ids')*/?)
ORDER BY t.direction_id, t.trip_headsign
`

type GetTripsForRouteInActiveServiceIDsParams struct {
	RouteID    string
	ServiceIds []string
}

func (q *Queries) GetTripsForRouteInActiveServiceIDs(ctx context.Context, arg GetTripsForRouteInActiveServiceIDsParams) ([]Trip, error) {
	query := getTripsForRouteInActiveServiceIDs
	var queryParams []interface{}
	queryParams = append(queryParams, arg.RouteID)
	if len(arg.ServiceIds) > 0 {
		for _, v := range arg.ServiceIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:('service_ids')*/?", strings.Repeat(",?", len(arg.ServiceIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:('service_ids')*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Trip
	for rows.Next() {
		var i Trip
		if err := rows.Scan(
			&i.ID,
			&i.RouteID,
			&i.ServiceID,
			&i.TripHeadsign,
			&i.TripShortName,
			&i.DirectionID,
			&i.BlockID,
			&i.ShapeID,
			&i.WheelchairAccessible,
			&i.BikesAllowed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTripsInBlock = `-- name: GetTripsInBlock :many
SELECT id
FROM trips
WHERE block_id = ?1
  AND service_id IN (/*SLICE:service_ids*/?)
`

type GetTripsInBlockParams struct {
	BlockID    sql.NullString
	ServiceIds []string
}

// Get all trip IDs in a specific block for the given service IDs
func (q *Queries) GetTripsInBlock(ctx context.Context, arg GetTripsInBlockParams) ([]string, error) {
	query := getTripsInBlock
	var queryParams []interface{}
	queryParams = append(queryParams, arg.BlockID)
	if len(arg.ServiceIds) > 0 {
		for _, v := range arg.ServiceIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:service_ids*/?", strings.Repeat(",?", len(arg.ServiceIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:service_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAgencies = `-- name: ListAgencies :many
SELECT
    id, name, url, timezone, lang, phone, fare_url, email
FROM
    agencies
ORDER BY
    id
`

func (q *Queries) ListAgencies(ctx context.Context) ([]Agency, error) {
	rows, err := q.query(ctx, q.listAgenciesStmt, listAgencies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Agency
	for rows.Next() {
		var i Agency
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Url,
			&i.Timezone,
			&i.Lang,
			&i.Phone,
			&i.FareUrl,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoutes = `-- name: ListRoutes :many
SELECT
    id,
    agency_id,
    short_name,
    long_name,
    "desc",
    type,
    url,
    color,
    text_color,
    continuous_pickup,
    continuous_drop_off
FROM
    routes
ORDER BY
    agency_id,
    id
`

func (q *Queries) ListRoutes(ctx context.Context) ([]Route, error) {
	rows, err := q.query(ctx, q.listRoutesStmt, listRoutes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Route
	for rows.Next() {
		var i Route
		if err := rows.Scan(
			&i.ID,
			&i.AgencyID,
			&i.ShortName,
			&i.LongName,
			&i.Desc,
			&i.Type,
			&i.Url,
			&i.Color,
			&i.TextColor,
			&i.ContinuousPickup,
			&i.ContinuousDropOff,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStops = `-- name: ListStops :many
SELECT
    id, code, name, "desc", lat, lon, zone_id, url, location_type, timezone, wheelchair_boarding, platform_code, direction, parent_station
FROM
    stops
ORDER BY
    id
`

func (q *Queries) ListStops(ctx context.Context) ([]Stop, error) {
	rows, err := q.query(ctx, q.listStopsStmt, listStops)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stop
	for rows.Next() {
		var i Stop
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Desc,
			&i.Lat,
			&i.Lon,
			&i.ZoneID,
			&i.Url,
			&i.LocationType,
			&i.Timezone,
			&i.WheelchairBoarding,
			&i.PlatformCode,
			&i.Direction,
			&i.ParentStation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTrips = `-- name: ListTrips :many
SELECT
    id, route_id, service_id, trip_headsign, trip_short_name, direction_id, block_id, shape_id, wheelchair_accessible, bikes_allowed
FROM
    trips
`

func (q *Queries) ListTrips(ctx context.Context) ([]Trip, error) {
	rows, err := q.query(ctx, q.listTripsStmt, listTrips)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Trip
	for rows.Next() {
		var i Trip
		if err := rows.Scan(
			&i.ID,
			&i.RouteID,
			&i.ServiceID,
			&i.TripHeadsign,
			&i.TripShortName,
			&i.DirectionID,
			&i.BlockID,
			&i.ShapeID,
			&i.WheelchairAccessible,
			&i.BikesAllowed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStopDirection = `-- name: UpdateStopDirection :exec
UPDATE stops
SET direction = ?
WHERE id = ?
`

type UpdateStopDirectionParams struct {
	Direction sql.NullString
	ID        string
}

func (q *Queries) UpdateStopDirection(ctx context.Context, arg UpdateStopDirectionParams) error {
	_, err := q.exec(ctx, q.updateStopDirectionStmt, updateStopDirection, arg.Direction, arg.ID)
	return err
}

const upsertImportMetadata = `-- name: UpsertImportMetadata :one
INSERT
OR REPLACE INTO import_metadata (
    id,
    file_hash,
    import_time,
    file_source
)
VALUES
    (1, ?, ?, ?) RETURNING id, file_hash, import_time, file_source
`

type UpsertImportMetadataParams struct {
	FileHash   string
	ImportTime int64
	FileSource string
}

func (q *Queries) UpsertImportMetadata(ctx context.Context, arg UpsertImportMetadataParams) (ImportMetadatum, error) {
	row := q.queryRow(ctx, q.upsertImportMetadataStmt, upsertImportMetadata, arg.FileHash, arg.ImportTime, arg.FileSource)
	var i ImportMetadatum
	err := row.Scan(
		&i.ID,
		&i.FileHash,
		&i.ImportTime,
		&i.FileSource,
	)
	return i, err
}
